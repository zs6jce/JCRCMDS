       //---------------------------------------------------------
       ctl-opt copyright('This program is free software, you can redistribute +
       it and/or modify it under the terms of the GNU General Public License +
       as published by the Free Software Foundation. See GNU General Public +
       License for detail.    Craig Rutledge      < www.jcrcmds.com > ');
       //---------------------------------------------------------
       // JCRUFINDR - Find string in user spaces
       //  call APIs to retrieve user space names
       //   use pointer to search user space for string
       //    if found, display or outfile view name
       //
       // Original intent was to search through ASC Sequel views to find files where
       // used. ASC data is always in first 5K or so bytes of user space.
       //
       // Performance problem was if 16Meg user space did not contain requested string.
       // Program was spinning through all 16 million bytes. Arbitrarily,
       // say string of 1000 X'00' is end of scannable data in user space. If user
       // spaces have longer strings of nulls then change value OneThousand00 to a higher value.
       //
       //  V7: Add option to click name in subfile to show entire user space contents
       //---------------------------------------------------------
       ctl-opt dftactgrp(*no) actgrp(*stgmdl) datfmt(*iso) timfmt(*iso)
       option(*nounref: *nodebugio) expropts(*resdecpos) bnddir('JCRCMDSDIR')
       stgmdl(*teraspace) alloc(*stgmdl);
 
       dcl-f JCRUFINDD workstn sfile(sbfdta1: rrn) infds(infds) usropn
       indds(ind);
       dcl-f JCRUFINDF usage(*output) extfile(extofile) extmbr(extombr) usropn;
 
       /define ApiErrDS
       /define Constants
       /define Dspatr
       /define Infds
       /define FunctionKeys
       /define Ind
       /define Quslobj
       /define Qusptrus
       /define Qusrusat
       /define Sds
       /define f_Quscrtus
       /define f_BuildString
       /define f_GetQual
       /define f_Qusrobjd
       /define f_RmvSflMsg
       /define f_SndCompMsg
       /define f_SndSflMsg
       /define f_SndStatMsg
       /define f_GetRowColumn
       /define f_GetApiISO
       /define f_GetDayName
       /define f_RtvMsgApi
       // *ENTRY
       /define p_JCRUFINDR
       /COPY JCRCMDS,JCRCMDSCPY
 
       dcl-s OneThousand00 uns(5) inz(1000);
       dcl-s savscLib like(scLib);
       dcl-s savscName like(scName);
       dcl-s savscRelation like(scRelation);
       dcl-s savscVal1 like(scVal1);
       dcl-s savscVal2 like(scVal2);
       dcl-s ThisUspace char(20);
       dcl-s EndOfSpace uns(10);
       dcl-s Hex00Count uns(5);
       dcl-s xx int(20);
       dcl-s yy int(20);
       dcl-s IsAnd1 ind;
       dcl-s IsAnd2 ind;
       dcl-s VarySearch1 varchar(25);
       dcl-s VarySearchLen1 uns(3);
       dcl-s Upper1 varchar(25);
       dcl-s VarySearch2 varchar(25);
       dcl-s VarySearchLen2 uns(3);
       dcl-s Upper2 varchar(25);
       dcl-s uSpaceSlice char(25) based(SlicePtr);
       dcl-s uSpaceChar char(1) based(uCharPtr);
       dcl-s LastChar char(1);
       dcl-s ExtOMbr char(10);
 
       //-----Show contents of user space ----------------------------
       dcl-pr  p_JCRUSPACER  extpgm('JCRUSPACER');
        *n char(20) const;  // p_uspacequal
       end-pr;
 
       //---------------------------------------------------------
       // Get pointer to user space created in validity checking program
       callp QUSPTRUS(UserSpaceName: ApiHeadPtr: ApiErrDS);
 
       // open either display file or outfile depending
 1b    if p_Output = '*';
          open JCRUFINDD;
          scDow = f_GetDayName();
 
 1x    elseif p_Output = '*OUTFILE';
          extOmbr = %subst(p_OutMbrOpt: 3: 10);
          extOfile = f_GetQual(p_OutFileQual);
          open JCRUFINDF;
 1e    endif;
 
       SCVAL1 = p_ScanString1;
       SCRELATION = %subst(p_Relations: 2: 3);
       SCVAL2 = p_ScanString2;
       SCNAME = %subst(p_ScanSpaces: 1: 10);
       SCLIB = %subst(p_ScanSpaces: 11: 10);
       exsr srLoadOutput;
 
       //---------------------------------------------------------
 1b    if p_Output = '*';
          exsr srShowSubfile;
          close JCRUFINDD;
          f_SndCompMsg(f_BuildString('JCRUFIND for & - completed':
          f_GetQual(scname + scLib)));
 
 1x    elseif p_Output = '*OUTFILE';
          close JCRUFINDF;
          f_SndCompMsg('File ' +%trimr(extOfile) + '  member ' +
          %trimr(ExtOmbr) + ' generated by MHUFIND.');
 1e    endif;
       *inlr = *on;
       return;
 
       //---------------------------------------------------------
       // load object name list
       begsr srShowSubfile;
       SflRcdNbr = 1;
 
 1b    dow not(InfdsFkey = f03);
          savscVal1 = scVal1;
          savscRelation = scRelation;
          savscVal2 = scVal2;
          savScName = scName;
          savScLib = scLib;
 
          Ind.sfldsp = (rrn > 0);
 2b       if (not Ind.sfldsp);
             f_SndSflMsg(ProgId: 'No strings match selection');
 2e       endif;
          Ind.sfldspctl = *on;
          csrrrn = 1;
 
          write msgctl;
          write sfooter1;
          exfmt sbfctl1;
 2b       if InfdsFkey = f03 or InfdsFkey = f12;
 LV          leavesr;
 2e       endif;
 
          f_RmvSflMsg(ProgId);
          ascVal1 = %bitor(Green: UL);
          ascRelat = %bitor(Green: UL);
          ascName = %bitor(Green: UL);
          ascLib = %bitor(Green: UL);
 
          // show user space contents if clicked
 2b       if csrrrn > 0;
             chain csrrrn sbfdta1;
 3b          if %found;
                callp p_JCRUSPACER(SBFNAME +  SCLIB);
                SflRcdNbr = csrrrn;
 3e          endif;
 2e       endif;
 
          //---------------------------------------------------------
          // 1) at least value1 must be entered.
          // 2) if value2 entered,
          // relationship must be 'AND' or 'OR '
          // 3) if relationship eq 'AND' or 'OR',
          // 4) value2 must be entered
          // 5) object name must be entered
          // 6) valid library name must be entered
          //---------------------------------------------------------
 2b       if scVal1 = *blanks;
             CsrRowColDS =
             f_GetRowColumn('SCVAL1':InfdsFile:InfdsLib:InfdsRcdfmt);
             ascval1 = %bitor(White: RI);
             f_SndSflMsg(ProgId: 'Must enter Scan For string');
 1i          iter;
 2e       endif;
 
          // and or relationship
 2b       if scVal2 > *blanks
             and not(scRelation = 'AND' or scRelation = 'OR');
             CsrRowColDS =
             f_GetRowColumn('SCRELATION':InfdsFile:InfdsLib:InfdsRcdfmt);
             ASCRELAT = %bitor(White: RI);
             f_SndSflMsg(ProgId: 'And/Or must = AND or OR');
 1i          iter;
 2e       endif;
 
          // do not need relationship if factor2 = *blanks
 2b       if scVal2 = *blanks;
             scRelation = *blanks;
 2e       endif;
 
 2b       if scName = *blanks;
             CsrRowColDS =
             f_GetRowColumn('SCNAME':InfdsFile:InfdsLib:InfdsRcdfmt);
             ascname = %bitor(White: RI);
             f_SndSflMsg(ProgId: 'Must enter Name Filter');
 1i          iter;
 2e       endif;
 
 2b       if scLib = *blanks;
             CsrRowColDS =
             f_GetRowColumn('SCLIB':InfdsFile:InfdsLib:InfdsRcdfmt);
             asclib = %bitor(White: RI);
             f_SndSflMsg(ProgId: 'Must enter Library');
 1i          iter;
 2x       else;
             f_QUSROBJD(scLib + 'QSYS': '*LIB': 'OBJD0100');
 3b          if ApiErrDS.BytesReturned > 0;
                CsrRowColDS =
                f_GetRowColumn('SCLIB':InfdsFile:InfdsLib:InfdsRcdfmt);
                asclib = %bitor(White: RI);
                f_SndSflMsg(ProgId: 'Library ' + %trimr(scLib) +
                ' not found');
 1i             iter;
 3e          endif;
 2e       endif;
 
 2b       if not(savscVal1 = scVal1
             and savscRelation = scRelation
             and savscVal2 = scVal2
             and savscName = scName
             and savscLib = sclib);
             exsr srLoadOutput;
 1i          iter;
 2e       endif;
          //---------------------------------------------------------
 2b       if (not Ind.sfldsp);
 1i          iter;
 2e       endif;
 1e    enddo;
       endsr;
 
       //---------------------------------------------------------
       begsr srLoadOutput;
       VarySearch1 = %trim(scVal1);
       VarySearchLen1 = %len(VarySearch1);
       %len(Upper1) = VarySearchLen1;
       VarySearch2 = %trim(scVal2);
       VarySearchLen2 = %len(VarySearch2);
       %len(Upper2) = VarySearchLen2;
       SflRcdNbr = 1;
 
 1b    if p_Output = '*';
          Ind.sfldsp = *off;
          Ind.sfldspctl = *off;
          rrn = 0;
          write sbfctl1;
 1e    endif;
 
       f_SndStatMsg(f_BuildString('Scanning & type *USRSPC - in progress':
       f_GetQual(scName + scLib)));
 
       // load user space name list
       callp QUSLOBJ(
             UserSpaceName:
             'OBJL0100':
             scName + scLib:
             '*USRSPC':
             ApiErrDS);
 
       // spin through list by moving QuslobjPtr pointer
       QuslobjPtr = ApiHeadPtr + ApiHead.OffSetToList;
 
 1b    for ForCount = 1 to ApiHead.ListEntryCount;
          sbfName = QuslobjDS.ObjNam;
          ThisUspace = sbfName + QuslobjDS.ObjLib;
 
          // Get last used date here, before scanning user space
          // as scanning alters last used date
 2b       if p_OutPut = '*OUTFILE';
             QusrObjDS = f_QUSROBJD(ThisUspace: '*USRSPC': 'OBJD0400');
             sbfCrtUsr = QusrObjDS.CreatedByUser;
             // user spaces show last used date as last changed date
             sbfLastUdt = f_GetApiISO(QusrObjDS.ChangeDateTime);
 2e       endif;
 
          // Get pointer to user space
          callp QUSPTRUS(
                ThisUspace:
                SlicePtr:
                ApiErrDS);
 
 2b       if ApiErrDS.BytesReturned > 0;
             f_SndSflMsg(ProgId: ApiErrDS.ErrMsgId + ': ' +
             %trimr(f_RtvMsgApi(ApiErrDS.ErrMsgId: ApiErrDS.MsgReplaceVal)));
 
 2x       else;
             // Get user space size so do not move pointer past that point
             callp QUSRUSAT(
                   QusrusatDS:
                   %size(QusrusatDS):
                   'SPCA0100':
                   ThisUspace:
                   ApiErrDS);
 
 3b          if VarySearchLen1 > VarySearchLen2;
                QusrusatDS.SpaceSize -= VarySearchLen1;
 3x          else;
                QusrusatDS.SpaceSize -= VarySearchLen2;
 3e          endif;
 
             Hex00Count = 0;
             IsAnd1 = *off;
             IsAnd2 = *off;
 
 3b          for xx = 1 to QusrusatDS.SpaceSize;
                // if thousand x00 are found, assume end of data and leave
                uCharPtr = SlicePtr;
 4b             if uSpaceChar = x'00';
                   Hex00Count += 1;
 5b                if Hex00Count = OneThousand00;
 3v                   leave;
 5e                endif;
 4x             else;
                   Hex00Count = 0;
 4e             endif;
 
                Upper1 = %xlate(lo:up:%subst(uSpaceSlice:1:VarySearchLen1));
                Upper2 = %xlate(lo:up:%subst(uSpaceSlice:1:VarySearchLen2));
 4b             if scRelation = *blanks;
 5b                if Upper1 = VarySearch1;
                      exsr srCompressAndWrite;
 3v                   leave;
 5e                endif;
 
 4x             elseif scRelation = 'OR';
 5b                if (Upper1 = VarySearch1 or Upper2 = VarySearch2);
                      exsr srCompressAndWrite;
 3v                   leave;
 5e                endif;
 
 4x             elseif scRelation = 'AND';
 5b                if Upper1 = VarySearch1;
                      IsAnd1 = *on;
 5e                endif;
 5b                if Upper2 = VarySearch2;
                      IsAnd2 = *on;
 5e                endif;
 5b                if IsAnd1 and IsAnd2;
                      exsr srCompressAndWrite;
 3v                   leave;
 5e                endif;
 4e             endif;
                SlicePtr += 1;
 3e          endfor;
 2e       endif;
          QuslobjPtr += ApiHead.ListEntrySize;
 1e    endfor;
       endsr;
 
       //---------------------------------------------------------
       // load from 30 spaces before xx into display
       // filter out anything less than x'40 as it will not display.
       // be careful if scan was found before 30 spaces into string
       // And finally, there can be a lot of spaces in the user space,
       // it will serve my purposes better if compressing multiple spaces
       // down to one single space to display more.
       //
       // There are some 16M user spaces out there and my scan
       // value may be last data in space at position 100.  Instead
       // of spinning through 16 million blanks, stop loading after
       // 1000 x00s
       //---------------------------------------------------------
       begsr srCompressAndWrite;
       LastChar = *blanks;
       sbfString = *blanks;
       Hex00Count = 0;
       yy = 0;
 
       // find start loading position
 1b    if (xx - 30) > 1;
          uCharPtr = SlicePtr - 30;
          EndOfSpace = xx - 30;
 1x    else;
          uCharPtr = SlicePtr;
          EndOfSpace = xx;
 1e    endif;
 
 1b    dou yy = 60;  // fill subfile field
 2b       if uSpaceChar <= x'40';
             Hex00Count += 1;
 3b          if Hex00Count = OneThousand00;
 1v             leave;
 3e          endif;
 3b          if LastChar > *blanks;
                yy += 1;
                %subst(sbfString:yy:1) = ' ';
                LastChar = *blanks;
 3e          endif;
 2x       else;
             Hex00Count = 0;
             yy += 1;
             %subst(sbfString:yy:1) = uSpaceChar;
             LastChar = uSpaceChar;
 2e       endif;
 
          EndOfSpace += 1;
 2b       if EndOfSpace > QusrusatDS.SpaceSize;
 1v          leave;
 2e       endif;
          uCharPtr += 1;
 1e    enddo;
 
 1b    if p_Output = '*';
          rrn += 1;
          write sbfdta1;
 
 1x    elseif p_OutPut = '*OUTFILE';
          write JCRUFINDFR;
 1e    endif;
       endsr;
