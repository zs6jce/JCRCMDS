       //---------------------------------------------------------
       ctl-opt copyright('This program is free software, you can redistribute +
       it and/or modify it under the terms of the GNU General Public License +
       as published by the Free Software Foundation. See GNU General Public +
       License for detail.    Craig Rutledge      < www.jcrcmds.com > ');
       //---------------------------------------------------------
       // JCRBNDR - Procedure names list from bnddir/svcpgm/mod
       //
       // If object is BNDDIR, must execute CL command dspbnddir to outfile to get info.
       // Wish there was API for that!
       //---------------------------------------------------------
       /define ControlStatements
       /define ApiErrDS
       /define Qbnlspgm
       /define Qbnlpgmi
       /define f_BuildString
       /define f_GetQual
       /define f_OvrPrtf
       /define f_Dltovr
       /define f_Quscrtus
       /define f_Qusrobjd
       /define f_SndCompMsg
       /define f_RunCmd
       /define f_DisplayLastSplf
       /define f_GetDayName
       /define Quslobj
       /define f_IsValidObj
       // *ENTRY
       /define p_JCRBNDR
       /COPY JCRCMDS,JCRCMDSCPY
 
       dcl-f JCRBNDF usage(*output) extfile(extOfile) extmbr(ExtOmbr) usropn;
       dcl-f JCRBNDP printer oflind(IsOverFlow) usropn;
 
       dcl-s extOmbr char(10);
       dcl-s LibObjQual char(21);
       dcl-s PgmSpace char(20) inz('JCRPGM    QTEMP');
       dcl-s ModuleSpace char(20) inz('JCRMODULE QTEMP');
       dcl-s SrvPgmSpace char(20) inz('JCRSRVPGM QTEMP');
       dcl-ds ApiHead3 likeds(GenericHeader) based(ApiHeadPtr3);
 
       //---------------------------------------------------------
       QusrObjDS = f_QUSROBJD(p_ObjQual: p_ObjTyp);
       %subst(p_ObjQual: 11: 10) = QusrObjDS.ReturnLib;
       LibObjQual = f_GetQual(p_ObjQual);
 
       // depending on output selection
 1b    if p_Output = '*OUTFILE';
          extOmbr = %subst(p_OutMbrOpt: 3: 10);
          extOfile = f_GetQual(p_OutFileQual);
          open JCRBNDF;
 1x    else;
          f_OvrPrtf('JCRBNDP': '*JOB': %subst(p_ObjQual: 1: 10));
          open JCRBNDP;
          scDow = f_GetDayName();
 
          scObjHead =
          f_BuildString('&  &   &   &':
          QusrObjDS.ObjNam: QusrObjDS.ReturnLib: p_ObjTyp: QusrObjDS.Text);
 
          //--------------------------------------------------------
 2b       if p_ObjTyp = '*BNDDIR';
             HeadVar = 'Bnddir     Srv Pgm    Lib        Module    ' +
             ' Lib        Procedure Name';
 2x       elseif p_ObjTyp = '*SRVPGM';
             HeadVar = 'Srv Pgm    Procedure Name';
 2x       elseif p_ObjTyp = '*MODULE';
             HeadVar = 'Module     Procedure Name';
 2e       endif;
 
          write PrtHead;
          IsOverFlow = *off;
 1e    endif;
 
       //--------------------------------------------------------
 1b    if p_ObjTyp = '*PGM';
          ApiHeadPtr = f_Quscrtus(PgmSpace);
 1e    endif;
 
       ApiHeadPtr2 = f_Quscrtus(SrvPgmSpace);
       ApiHeadPtr3 = f_Quscrtus(ModuleSpace);
 
 1b    if QusrObjDS.Type = '*BNDDIR';
          f_GetBndDir(QusrObjDS.ObjNam: QusrObjDS.ReturnLib);
 
 1x    elseif QusrObjDS.Type = '*SRVPGM';
          f_GetSrvPgm(QusrObjDS.ObjNam: QusrObjDS.ReturnLib);
 
 1x    elseif QusrObjDS.Type = '*MODULE';
          f_GetModule(QusrObjDS.ObjNam: QusrObjDS.ReturnLib);
 
 1x    elseif QusrObjDS.Type = '*PGM';
          f_GetProceduresinPgm(QusrObjDS.ObjNam: QusrObjDS.ReturnLib);
 1e    endif;
 
 1b    if p_Output = '*PRINT'
          or p_Output = '*';
          close JCRBNDP;
          f_Dltovr('JCRBNDP');
          f_DisplayLastSplf('JCRBNDR': p_Output);
 
 1x    elseif p_Output = '*OUTFILE';
          f_SndCompMsg('File ' +%trimr(extOfile)+ ' generated by JCRBND.');
 1e    endif;
 
       *inlr = *on;
       return;
 
       //---------------------------------------------------------
       // Excute a API to get all service program names used in a program.
       //  Then execute the f_GetSrvPgm to print them out.
       //---------------------------------------------------------
       dcl-proc f_GetProceduresinPgm;
        dcl-pi *n;
         p_ObjName char(10);
         p_ObjLib char(10);
        end-pi;
 
        dcl-ds Pgml0200DS qualified based(Pgml0200PTR);
         Name char(10) pos(21);
         Lib char(10) pos(31);
        end-ds;
 
        callp QBNLPGMI(
              PgmSpace:
              'PGML0200':
              p_ObjName + p_ObjLib:
              ApiErrDS);
 
        Pgml0200Ptr = ApiHeadPtr + ApiHead.OffSetToList;
 
 1b     for ForCount = 1 to ApiHead.ListEntryCount;
 2b        if Pgml0200DS.Lib <> 'QSYS';
 3b           if Pgml0200DS.Lib <> ' ';
                 Pgml0200DS.Lib = '*LIBL';
 3e           endif;
              f_GetSrvPgm(Pgml0200DS.Name:Pgml0200DS.Lib);
 2e        endif;
 
           Pgml0200Ptr += ApiHead.ListEntrySize;
 1e     endfor;
        return;
       end-proc;
 
       //---------------------------------------------------------
       // There is no API to get bind directory entries!.
       //  Execute DSPBNDDIR command to *OUTFILE, then process outfile.
       //---------------------------------------------------------
       dcl-proc f_GetBndDir;
        dcl-pi *n;
         p_ObjName char(10);
         p_ObjLib char(10);
        end-pi;
 
        dcl-f JCRBNDFB usropn;
        dcl-ds inputDS likerec(QBNDSPBD);
 
        f_RunCmd('DSPBNDDIR BNDDIR(' +
        f_GetQual(p_ObjName + p_ObjLib) +
        ') OUTPUT(*OUTFILE) ' +
        ' OUTFILE(JCRBNDFB) OUTMBR(*FIRST *REPLACE)');
 
        jcrBndDir = p_ObjName;
        jcrBndDirL = p_ObjLib;
 
        open JCRBNDFB;
        read JCRBNDFB inputDS;
 1b     dow not %eof;
 
          //-------------------------------------------------
          // Directory entries sometimes have *LIBL for the
          // service program or *module name, and these objects are not
          // in your library list. If object not in your library list,
          //  execute function to search *ALLUSR for object.
          //---------------------------------------------------
           inputDS.bnolnm
           = f_GetLib(inputDS.bnobnm: inputDS.bnolnm: inputDS.bnobtp);
 
          //---------------------------------------------------
 2b        if inputDS.bnobtp = '*SRVPGM';
              f_GetSrvPgm(inputDS.bnobnm: inputDS.bnolnm);
 2x        elseif inputDS.bnobtp = '*MODULE';
              f_GetModule(inputDS.bnobnm: inputDS.bnolnm);
 2e        endif;
 
           read JCRBNDFB inputDS;
 1e     enddo;
 
        close JCRBNDFB;
        f_RunCmd('CLRPFM JCRBNDFB');
        return;
       end-proc;
 
       //---------------------------------------------------------
       dcl-proc f_GetSrvPgm;
        dcl-pi *n;
         p_ObjName char(10);
         p_ObjLib char(10);
        end-pi;
 
        jcrSrvPgm = p_ObjName;
        jcrSrvPgmL = p_ObjLib;
        jcrModule = *blanks;
        jcrModuleL = *blanks;
 
        callp QBNLSPGM(
              SrvPgmSpace:
              'SPGL0600':
              p_ObjName + p_ObjLib:
              ApiErrDS);
 
        SrvPgmPtr = ApiHeadPtr2 + ApiHead2.OffSetToList;
 
 1b     for ForCount2 = 1 to ApiHead2.ListEntryCount;
           jcrProc = %subst(SrvPgmDS.BigProcName:1:SrvPgmDS.LengthOfName);
 
           f_PutPrint(
           jcrBndDir:
           jcrBndDirL:
           jcrSrvPgm:
           jcrSrvPgmL:
           jcrModule:
           jcrModuleL:
           jcrProc);
 
           SrvPgmPtr += ApiHead2.ListEntrySize;
 1e     endfor;
 
        jcrSrvPgm = *blanks;
        jcrSrvPgmL = *blanks;
        return;
       end-proc;
 
       //---------------------------------------------------------
       dcl-proc f_GetModule;
        dcl-pi *n;
         p_ObjName char(10);
         p_ObjLib char(10);
        end-pi;
 
        dcl-s ForCount int(10);
        dcl-s ProcNameRaw char(256) based(rawnameptr);
 
        dcl-ds ListEntryDS qualified based(ListEntryPtr);
         SizeOfThisEnt int(10) pos(1);
         OffsetToProc int(10) pos(29);
         LengthOfName int(10) pos(33);
        end-ds;
 
       // List Module Information
        dcl-pr Qbnlmodi extpgm('QBNLMODI');
         *n char(20);  // user space
         *n char(8) const;  // api format
         *n char(20) const;  // object and lib
         *n like(ApiErrDS);
        end-pr;
 
        jcrModule = p_ObjName;
        jcrModuleL = p_ObjLib;
 
        callp QBNLMODI(
              ModuleSpace:
              'MODL0300':
              p_ObjName + p_ObjLib:
              ApiErrDS);
 
        ListEntryPtr = ApiHeadPtr3 + ApiHead3.OffSetToList;
 
 1b     for ForCount = 1 to ApiHead3.ListEntryCount;
 2b        if ListEntryDS.LengthOfName > %size(jcrProc);
              ListEntryDS.LengthOfName = %size(jcrProc);
 2e        endif;
 
           RawNamePtr = ApiHeadPtr3 + ListEntryDS.OffsetToProc;
           jcrProc = %subst(procNameRaw: 1: ListEntryDS.LengthOfName);
 
 2b        if %subst(jcrProc: 1: 2) <> '_Q';
              f_PutPrint(
              jcrBndDir:
              jcrBndDirL:
              jcrSrvPgm:
              jcrSrvPgmL:
              jcrModule:
              jcrModuleL:
              jcrProc);
 2e        endif;
           ListEntryPtr += ListEntryDS.SizeOfThisEnt;
 1e     endfor;
 
        jcrModule = *blanks;
        jcrModuleL = *blanks;
        return;
       end-proc;
 
       //---------------------------------------------------------
       dcl-proc f_PutPrint;
        dcl-pi *n;
         jcrBndDir char(10);
         jcrBndDirL char(10);
         jcrSrvPgm char(10);
         jcrSrvPgmL char(10);
         jcrModule char(10);
         jcrModuleL char(10);
         jcrProc char(256);
        end-pi;
 
 1b     if p_Output = '*PRINT' or p_Output = '*';
 2b        if QusrObjDS.Type = '*BNDDIR';
              DetailVar = jcrBndDir + ' ' +
              jcrSrvPgm + ' ' +
              jcrSrvPgmL + ' ' +
              jcrModule + ' ' +
              jcrModuleL + ' ' +
              jcrProc;
 
 2x        elseif QusrObjDS.Type = '*SRVPGM' or QusrObjDS.Type = '*PGM';
              DetailVar = jcrSrvPgm + ' ' + jcrProc;
 
 2x        elseif QusrObjDS.Type = '*MODULE';
              DetailVar = jcrModule + ' ' + jcrProc;
 2e        endif;
 
           write PrtDetail;
 2b        if IsOverFlow;
              write PrtHead;
              IsOverFlow = *off;
 2e        endif;
 
 1x     elseif p_Output = '*OUTFILE';
           write JCRBNDFR;
 1e     endif;
 
       end-proc;
 
 
       //---------------------------------------------------------
       // Directory entries sometimes have *LIBL for the
       // service program or *module name, and these objects are not
       // in your library list. Search *ALLUSR for object then return library name.
       //---------------------------------------------------------
       dcl-proc f_GetLib;
        dcl-pi *n char(10);  // returned library name
         p_ObjName char(10);
         p_ObjLib char(10);
         p_ObjType char(7);
        end-pi;
 
        dcl-ds ApiHead4 likeds(GenericHeader) based(ApiHeadPtr4);
        dcl-s LiblSpace char(20) inz('JCRLIBL   QTEMP');
 
 1b     if f_IsValidObj(p_ObjName: p_ObjLib: p_ObjType);
           return p_ObjLib;
 1e     endif;
 
        ApiHeadPtr4 = f_Quscrtus(LiblSpace);
 
        callp QUSLOBJ(
              LiblSpace:
              'OBJL0100':
              p_ObjName + '*ALLUSR':
              p_ObjType:
              ApiErrDS);
 
 1b     if ApiErrDS.BytesReturned > 0 or ApiHead4.ListEntryCount = 0;
           return p_ObjLib;
 1e     endif;
 
        QuslobjPtr = ApiHeadPtr4 + ApiHead4.OffSetToList;
        return QuslobjDS.ObjLib;
       end-proc;
